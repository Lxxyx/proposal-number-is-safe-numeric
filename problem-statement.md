The `Number.isSafeNumeric` has received many feedbacks from TC39 conference and Matrix discussion. Thanks for everyone's feedbacks and suggestions.

Here is the problem statement.

## Changes from slides

1. Clarify the real problem we are facing
2. Remove strict format rules by default, align with ECMAScript StringNumericLiteral format.
3. Remove `Number.MAX_SAFE_INTEGER` limits
4. Add Identification of unsafe numeric string.
5. Add more faq for changes and feedbacks.

## Motivation

In our project, we often face two problems:

1. We need to validate the input is a numeric string

- Handle api response, due to java.Long overflow problem, so every number value is converted to string type, we need validate it before using it.
- Handle user input, people fill forms, sheets, etc.

These scenarios require us to do the same thing everywhere, producing lots of duplicate code

2. We need avoid precision loss with numeric strings

- For Sheets application, when loading data from database or handle user input, we need to check if the numeric string have more than 15 significant digits. To avoid rendering wrong value or produce dirty data to user.
- May not be a common problem, but it's a real problem for us, and developers are not aware of this until they produce this bug.

So, we want to create a new method, make us less painful to handle those problems.

This is `Number.isSafeNumeric`.

A `safe numeric string` contains 2 parts:

1. Format rules

- Validate input satisfies ECMAScript [StringNumericLiteral](https://tc39.es/ecma262/multipage/abstract-operations.html#prod-StringNumericLiteral) format(inter), which can be correctly parsed by `Number()`.
- Unify type coercion traps solved by this method. (`null`, `undefined`, `''`) -> `0`, `123abc` -> `123` etc.

After ensure input is numeric string. This method will check about value safety.

2. Value Safety

- Validates the real number value of numeric string, retains its original precision and integrity after being converted to an IEEE 754 standard-compliant JavaScript Number.
- Also notify developers, if this method returns `false`, you should use correct number parsing method to handle this input. (BigInt, Decimal.js, etc.)

## Value Safety Identification

Notes in ECMAScript Specification

ECMAScript [Number::toString](https://tc39.es/ecma262/#sec-numeric-types-number-tostring) notes: `If x is any Number value other than -0ð”½, then ToNumber(ToString(x)) is x.`

1. If `x` is a JavaScript Number value(not -0ð”½)
2. There must exist a numeric string `str` generated by `ToString(x)`
3. The `ToNumber(str)` must be `x`

### UnSafe Numeric String Definition

1. If `str` is a numeric string
2. When `ToNumber(str)` is called, due to IEEE-754 double precision limits and ECMAScript ([RoundMVResult](https://tc39.es/ecma262/#sec-roundmvresult)), the significant digits of `str` **maybe modified during conversion**.
3. This means the `str` doesn't have an exact representation of `x` due to modified significant digits.
4. And it can't be converted back to the same numeric string, which means `unsafe`.
5. That's `MV(str) !== MV(ToString(ToNumber(str)))`

for example: `Number('1234.5678901234567891') -> 1234.567890123457`, the value can not be converted back, so it's unsafe.

## Examples

### Format Rules

#### Valid

```javascript
'123' // true
'0.1' // true
'1e-25' // true
'100000000000000000000' // true
'.1' // true
'1.' // true
'0.10' // true
```

#### Invalid

```javascript
null // false
undefined // false
;('') // false
;('123abc') // false
;('123.45.67') // false
// any other formats do not satisfy ECMAScript StringNumericLiteral format
```

### Value Safety

#### Valid

```javascript
// Integer
'123' // true
'9007199254740991' // true, can be parsed correctly
'100000000000000000000' // true, although it's larger than `Number.MAX_SAFE_INTEGER`, but it can be parsed correctly using Number().

// Float
'0.1' // true, although it's stored as 0.10000000000000000555, but within double precision format, it's 0.1
'1234.000000000000000000000000' // true, within double precision format, it's 1234, same as above
'1234.5678' // true, within double precision format, it's 1234.5678
'0.0000000000000000000000001' // true, 1e-25, within safe range of significant digits(15-17)
'1e-25' // true, same as above
```

#### Invalid

```javascript
// Integer
'9007199254740993' // false, when parsed to number, is 9007199254740992
'100000000000000000001' // false, when parsed to number, is 100000000000000000000

// Float
'0.12345678901234567891' // false, when parsed to number is 0.12345678901234568
'1234.5678901234567891' // false, when parsed to number is 1234.567890123457
```

## Real World Use Cases

### Format Rules

#### E-commerce website shopping cart

The backend api may not always return number with string type, it may be empty or invalid due to some part of system issues(like traffic limit of this sub-system).

> The return value of `fetchShoppingCartItemsCount` is a object, like `{ count: '123' }`, and also can be `{ count: null }` or `{ error: 'TRAFFIC_LIMIT' }`.

```javascript
const { count } = await fetchShoppingCartItemsCount()
if (typeof count !== 'string' || Number.isNaN(parseInt(count)) || !/^\d+$/.test(count)) {
  reportError('Invalid count')
  return
}

// Also for sub-subsequent operations(user create new order or delete order record)
renderShoppingCartItemsCountUI(parseInt(count))

userShoppingCart.onAdd((count) => {
  count += 1
  renderShoppingCartItemsCountUI(count)
  saveToDatabase(count)
})

userShoppingCart.onDelete((count) => {
  count -= 1
  renderShoppingCartItemsCountUI(count)
  saveToDatabase(count)
})
```

### Value Safety

#### Sheets application

For number type column, when user input is a string, we need to do those things by sequence:

1. Validate the format is correct
2. Parse the string to number, and save it to the database
3. Display the number to user(this step use Number.prototype.toString())

For this usecase, if user input is "9007199254740993", when save to the database, it will be 9007199254740992, and when display to user, it will be 9007199254740992.

This becomes a real problem we are facing.

## FAQ

### Remove strict format rules by default?

Yes.

If we align with ECMAScript StringNumericLiteral format, we can accept scientific notation string, like `1e-25`.

Which maybe more familiar to developers, since this is the common way to write numbers in JavaScript.

### Validating string but not transform to number?

There are many use cases that we need validate the string before using it.

- Render Web Sheets, especially for number type column, we need to validate the string before using it.
- Get shopping cart items count(original value type is string, because our backend system is java, for avoid java.Long overflow, so every number value is converted to string type), display to user, when user add new items, we need to transform string to numbers, and save it to the database.
- User inputs, like collect age, height, weight, etc.

### When calculation with safely numeric string number value, this result still not correct?

Yes. This is the problem brought by IEEE 754 double-precision format, I think we can't solve this problem and it's also not the scope of this method.

For example:

```javascript
const a = '0.1'
const b = '0.2'
const c = a + b
console.log(c) // 0.30000000000000004
```

And we just want to clarify, without any calculation, just transform numeric string to number, the result is maybe incorrect(`Number("9007199254740993") -> 9007199254740992`), that's why we need to use `Number.isSafeNumeric`.

The method is for reduce error, the issues brought by IEEE 754 double-precision format can't be solved by this method.

### Remove value safety limits of `Number.MAX_SAFE_INTEGER`?

Yes, Thanks for feedback from @ljharb and @Jesse Alama and other people.

After discussion, we realize the core problem is some numeric string cannot be parsed correctly using `Number()`, the and it's not the problem of `Number.MAX_SAFE_INTEGER`.

For example:

```javascript
Number('100000000000000000000') // 1e+21
```

So, we decide to remove the value safety limits of `Number.MAX_SAFE_INTEGER`, which can focus on the real problem.

### The floating number store in javascript is not the real number value of numeric string?

Yes, but we need to clarify about numeric string / number store in javascript / IEEE 754 double-precision number displayed in decimal.

Just use `0.1`.

- numeric string: `0.1`, the real number value is `0.1`
- number stored in javascript: `Number('0.1').toFixed(25)` -> `0.1000000000000000055511151`, if you want you can get more digits.
- IEEE 754 double-precision number to decimal: **due to the 52-bit mantissa limit, the closest representable value to 0.1 is rounded to approximately `0.1000000000000000` in decimal.** And javascript ToString() method will choose the shortest string to represent the number, it's `0.1`.

Also ECMAScript [Number::toString](https://tc39.es/ecma262/#sec-numeric-types-number-tostring) notes: `If x is any Number value other than -0ð”½, then ToNumber(ToString(x)) is x.`

For 0.1, `Number(0.1.toString()) === 0.1`. Which also have string -> number conversion.

### Does this method going to create a numeric string for every number?

No.

The input is already a numeric string, this means it's have fixed digits, which means a real number.

### How about a better name?

Yes, actually I'm already considering this.

Some history:

- `String.prototype.isDigit`
- `String.isSafeDecimal`
- `[NOW] Number.isSafeNumeric`

Some names won't be used but in the discussion:

- `Number.isSafeParseable`
- `Number.isPreciseNumeric`

For what reason, if there exists better name, we could use it(discussion welcome).

### How about change behavior, provide a method for parse numeric string to number?

Yes, this is also a good idea. We can talk about this in the next stage.

For example:

```javascript
Number.parseSafe('123') // 123
Number.parseSafe('0.12345678901234567891') // throw error
```
